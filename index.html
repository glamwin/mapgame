<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Шашки + мини Doom 3D</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    header {
      padding: 12px 16px 4px;
      text-align: center;
    }
    h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    p.subtitle {
      margin: 4px 0 0;
      font-size: 12px;
      color: #9ca3af;
    }
    .layout {
      width: 100%;
      max-width: 960px;
      padding: 8px 16px 24px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }
    button {
      background: #1d4ed8;
      color: #e5e7eb;
      border: 1px solid #1d4ed8;
      border-radius: 999px;
      padding: 5px 11px;
      font-size: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 0.15s ease-out, transform 0.1s ease-out, box-shadow 0.1s ease-out;
    }
    button.secondary {
      background: #0f172a;
      border-color: #334155;
    }
    button.active {
      background: #16a34a;
      border-color: #16a34a;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }

    .container {
      background: radial-gradient(circle at top, #0b1120 0, #020617 50%, #000 100%);
      padding: 12px;
      border-radius: 16px;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 36px rgba(0,0,0,0.7);
    }

    canvas {
      display: block;
      border-radius: 10px;
      border: 1px solid #111827;
      background: #020617;
    }

    #checkersCanvas {
      width: 480px;
      height: 480px;
    }
    #doomCanvas {
      width: 640px;
      height: 360px;
    }

    .info {
      font-size: 12px;
      color: #9ca3af;
      text-align: center;
      max-width: 960px;
    }
    .info strong { color: #e5e7eb; }

    .log {
      font-size: 11px;
      color: #6b7280;
      font-family: monospace;
      background: rgba(15,23,42,0.85);
      border-radius: 10px;
      padding: 6px 10px;
      border: 1px solid #111827;
      max-height: 120px;
      overflow-y: auto;
      white-space: pre-line;
      width: 100%;
      max-width: 960px;
    }
  </style>
</head>
<body>
<header>
  <h1>Шашки + мини Doom-подобная 3D-арена</h1>
  <p class="subtitle">2D шашки + raycasting-псевдо-3D с оружием и целью. Всё без библиотек.</p>
</header>

<div class="layout">
  <div class="controls">
    <button id="modeCheckers" class="active">Режим шашек</button>
    <button id="modeDoom" class="secondary">Режим 3D арены</button>
    <button id="resetCheckers" class="secondary">Сбросить шашки</button>
  </div>

  <div class="container">
    <canvas id="checkersCanvas" width="480" height="480"></canvas>
    <canvas id="doomCanvas" width="640" height="360" style="display:none;"></canvas>
  </div>

  <div class="info" id="infoText">
    <div><strong>Шашки:</strong> клик по своей шашке → клик по диагональной чёрной клетке (без боёв, просто ход).</div>
    <div><strong>3D арена:</strong> Игрок 1 — W/S вперёд/назад, A/D влево/вправо (страйф), Q/E поворот, Space — выстрел. Игрок 2 — стрелки двигают цель. Попадания по цели снимают HP.</div>
  </div>

  <div class="log" id="logBox">Готово. Сейчас включён режим шашек.</div>
</div>

<script>
(function() {
  const logBox = document.getElementById('logBox');
  function log(msg) {
    const t = new Date().toLocaleTimeString('ru-RU', { hour12: false });
    const line = `[${t}] ${msg}`;
    logBox.textContent = line + "\n" + logBox.textContent;
  }

  const modeCheckersBtn = document.getElementById('modeCheckers');
  const modeDoomBtn = document.getElementById('modeDoom');
  const resetCheckersBtn = document.getElementById('resetCheckers');
  const infoText = document.getElementById('infoText');
  const checkersCanvas = document.getElementById('checkersCanvas');
  const doomCanvas = document.getElementById('doomCanvas');

  let mode = 'checkers';

  function setMode(newMode) {
    mode = newMode;
    if (newMode === 'checkers') {
      modeCheckersBtn.classList.add('active');
      modeCheckersBtn.classList.remove('secondary');
      modeDoomBtn.classList.remove('active');
      modeDoomBtn.classList.add('secondary');
      checkersCanvas.style.display = 'block';
      doomCanvas.style.display = 'none';
      infoText.innerHTML =
        '<div><strong>Шашки:</strong> клик по своей шашке → клик по диагональной чёрной клетке (упрощённые правила, без боёв).</div>' +
        '<div><strong>3D арена:</strong> переключись в режим 3D, чтобы протестировать псевдо-Doom.</div>';
      log('Включён режим шашек.');
    } else {
      modeDoomBtn.classList.add('active');
      modeDoomBtn.classList.remove('secondary');
      modeCheckersBtn.classList.remove('active');
      modeCheckersBtn.classList.add('secondary');
      checkersCanvas.style.display = 'none';
      doomCanvas.style.display = 'block';
      infoText.innerHTML =
        '<div><strong>3D арена:</strong> Игрок 1 — W/S вперёд/назад, A/D влево/вправо (страйф), Q/E поворот, Space — выстрел.</div>' +
        '<div>Игрок 2 — стрелки ←↑↓→ двигают цель. Попадания по цели снимают HP. **Без хила**.</div>';
      log('Включён режим 3D арены.');
    }
  }

  modeCheckersBtn.addEventListener('click', () => setMode('checkers'));
  modeDoomBtn.addEventListener('click', () => setMode('doom'));

  // ========================
  // ШАШКИ (упрощённо)
  // ========================
  const bctx = checkersCanvas.getContext('2d');
  const SIZE = 8;
  const CELL = checkersCanvas.width / SIZE;

  // board[y][x] = {color:'w'|'b', king:false}
  let board = [];
  let currentPlayer = 'w';
  let selected = null;

  function initBoard() {
    board = [];
    for (let y = 0; y < SIZE; y++) {
      const row = [];
      for (let x = 0; x < SIZE; x++) row.push(null);
      board.push(row);
    }
    // чёрные сверху (0-2), белые снизу (5-7)
    for (let y = 0; y < 3; y++) {
      for (let x = 0; x < SIZE; x++) {
        if ((x + y) % 2 === 1) {
          board[y][x] = { color: 'b', king: false };
        }
      }
    }
    for (let y = 5; y < 8; y++) {
      for (let x = 0; x < SIZE; x++) {
        if ((x + y) % 2 === 1) {
          board[y][x] = { color: 'w', king: false };
        }
      }
    }
    currentPlayer = 'w';
    selected = null;
    drawBoard();
  }

  function drawBoard() {
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        const dark = (x + y) % 2 === 1;
        bctx.fillStyle = dark ? '#111827' : '#e5e7eb';
        bctx.fillRect(x * CELL, y * CELL, CELL, CELL);

        if (selected && selected.x === x && selected.y === y) {
          bctx.fillStyle = 'rgba(250,204,21,0.3)';
          bctx.fillRect(x * CELL, y * CELL, CELL, CELL);
        }

        const piece = board[y][x];
        if (piece) {
          bctx.beginPath();
          bctx.arc(
            x * CELL + CELL / 2,
            y * CELL + CELL / 2,
            CELL * 0.35,
            0, Math.PI * 2
          );
          bctx.fillStyle = piece.color === 'w' ? '#f9fafb' : '#0f172a';
          bctx.fill();
          bctx.lineWidth = 2;
          bctx.strokeStyle = piece.color === 'w' ? '#e5e7eb' : '#374151';
          bctx.stroke();
        }
      }
    }
  }

  function getCellFromEvent(evt) {
    const rect = checkersCanvas.getBoundingClientRect();
    const x = Math.floor((evt.clientX - rect.left) / CELL);
    const y = Math.floor((evt.clientY - rect.top) / CELL);
    if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return null;
    return { x, y };
  }

  function handleBoardClick(evt) {
    if (mode !== 'checkers') return;
    const cell = getCellFromEvent(evt);
    if (!cell) return;
    const { x, y } = cell;
    if ((x + y) % 2 === 0) return; // только чёрные клетки

    const piece = board[y][x];
    if (selected) {
      if (selected.x === x && selected.y === y) {
        selected = null;
        drawBoard();
        return;
      }
      tryMoveSimple(selected.x, selected.y, x, y);
      return;
    } else {
      if (piece && piece.color === currentPlayer) {
        selected = { x, y };
        drawBoard();
      }
    }
  }

  // упрощённый ход: только на одну диагональ вперёд, без боёв и дамок
  function tryMoveSimple(fromX, fromY, toX, toY) {
    const piece = board[fromY][fromX];
    if (!piece) { selected = null; drawBoard(); return; }
    if (board[toY][toX]) { selected = null; drawBoard(); return; }

    const dx = toX - fromX;
    const dy = toY - fromY;
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if (absDx === 1 && absDy === 1) {
      const dir = piece.color === 'w' ? -1 : 1; // белые снизу → ход вверх
      if (dy !== dir) {
        selected = null;
        drawBoard();
        return;
      }
      board[toY][toX] = piece;
      board[fromY][fromX] = null;
      selected = null;
      currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
      drawBoard();
      log(`Ход сделан. Теперь ходит ${currentPlayer === 'w' ? 'белые' : 'чёрные'}.`);
      return;
    }
    selected = null;
    drawBoard();
  }

  checkersCanvas.addEventListener('click', handleBoardClick);
  resetCheckersBtn.addEventListener('click', () => {
    initBoard();
    log('Шашки сброшены.');
  });

  initBoard();

  // ========================
  // DOOM-ПОДОБНАЯ 3D АРЕНА
  // ========================
  const dctx = doomCanvas.getContext('2d');
  const DW = doomCanvas.width;
  const DH = doomCanvas.height;

  // карта 2D (0 - пусто, 1 - стена)
  const MAP_W = 10;
  const MAP_H = 10;
  const TILE = 1; // логически 1 юнит, не важно

  const map = [
    [1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,0,0,1,0,0,1],
    [1,0,0,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,0,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1],
  ];

  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code] = true; });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  const player = {
    x: 2.5,
    y: 2.5,
    angle: 0,
    speed: 2.5,
    rotSpeed: 2.5,
  };

  const enemy = {
    x: 7.5,
    y: 7.5,
    hp: 100,
    maxHp: 100,
    alive: true,
  };

  const bullets = [];
  let shootCooldown = 0;

  const FOV = Math.PI / 3; // 60°
  const NUM_RAYS = DW; // по одному лучу на пиксель

  function isWall(x, y) {
    if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return true;
    return map[Math.floor(y)][Math.floor(x)] === 1;
  }

  function updateDoom(dt) {
    // управление игроком
    const moveForward = keys['KeyW'];
    const moveBackward = keys['KeyS'];
    const strafeLeft = keys['KeyA'];
    const strafeRight = keys['KeyD'];
    const turnLeft = keys['KeyQ'];
    const turnRight = keys['KeyE'];

    if (turnLeft) player.angle -= player.rotSpeed * dt;
    if (turnRight) player.angle += player.rotSpeed * dt;

    const cos = Math.cos(player.angle);
    const sin = Math.sin(player.angle);

    let dx = 0;
    let dy = 0;

    if (moveForward) {
      dx += cos * player.speed * dt;
      dy += sin * player.speed * dt;
    }
    if (moveBackward) {
      dx -= cos * player.speed * dt;
      dy -= sin * player.speed * dt;
    }
    if (strafeLeft) {
      dx += -sin * player.speed * dt;
      dy += cos * player.speed * dt;
    }
    if (strafeRight) {
      dx += sin * player.speed * dt;
      dy += -cos * player.speed * dt;
    }

    const newX = player.x + dx;
    const newY = player.y + dy;
    if (!isWall(newX, player.y)) player.x = newX;
    if (!isWall(player.x, newY)) player.y = newY;

    // движение врага (Игрок 2 — стрелки)
    const enemySpeed = 2.0;
    let ex = enemy.x;
    let ey = enemy.y;
    if (keys['ArrowUp']) ey -= enemySpeed * dt;
    if (keys['ArrowDown']) ey += enemySpeed * dt;
    if (keys['ArrowLeft']) ex -= enemySpeed * dt;
    if (keys['ArrowRight']) ex += enemySpeed * dt;
    if (!isWall(ex, enemy.y)) enemy.x = ex;
    if (!isWall(enemy.x, ey)) enemy.y = ey;

    // стрельба
    shootCooldown -= dt;
    if (shootCooldown < 0) shootCooldown = 0;
    if (keys['Space'] && shootCooldown === 0) {
      shootBullet();
      shootCooldown = 0.4;
    }

    // апдейт пуль
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      if (isWall(b.x, b.y)) {
        bullets.splice(i, 1);
        continue;
      }
      // попадание во врага
      if (enemy.alive) {
        const dx = enemy.x - b.x;
        const dy = enemy.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 0.3) {
          enemy.hp -= 40;
          bullets.splice(i, 1);
          log('Попадание по цели. HP врага: ' + Math.max(0, enemy.hp).toFixed(0));
          if (enemy.hp <= 0) {
            enemy.alive = false;
            enemy.hp = 0;
            log('Враг уничтожен.');
          }
        }
      }
    }
  }

  function shootBullet() {
    const speed = 8;
    const cos = Math.cos(player.angle);
    const sin = Math.sin(player.angle);
    bullets.push({
      x: player.x,
      y: player.y,
      vx: cos * speed,
      vy: sin * speed,
    });
    log('Выстрел.');
  }

  function castRay(rayAngle) {
    // простой шаговый raymarching
    const step = 0.02;
    let dist = 0;
    let hitWall = false;
    let hitX = player.x;
    let hitY = player.y;

    const cos = Math.cos(rayAngle);
    const sin = Math.sin(rayAngle);

    while (!hitWall && dist < 20) {
      dist += step;
      hitX = player.x + cos * dist;
      hitY = player.y + sin * dist;
      if (isWall(hitX, hitY)) {
        hitWall = true;
        break;
      }
    }
    if (!hitWall) return { dist: 20, hitWall: false };
    return { dist, hitWall: true };
  }

  function drawDoom() {
    // фон: небо и пол
    dctx.fillStyle = '#020617';
    dctx.fillRect(0, 0, DW, DH / 2); // "небо"
    dctx.fillStyle = '#0b1120';
    dctx.fillRect(0, DH / 2, DW, DH / 2); // "пол"

    // стены — raycasting
    const halfFov = FOV / 2;
    const distProjPlane = (DW / 2) / Math.tan(halfFov);

    for (let x = 0; x < DW; x++) {
      const rayScreenPos = (x - DW / 2);
      const rayAngle = player.angle + Math.atan(rayScreenPos / distProjPlane);

      const ray = castRay(rayAngle);
      let dist = ray.dist;
      // устранение рыбьего глаза
      dist *= Math.cos(rayAngle - player.angle);

      const wallHeight = (TILE * distProjPlane) / dist;
      const startY = Math.floor(DH / 2 - wallHeight / 2);
      const endY = Math.floor(DH / 2 + wallHeight / 2);

      let shade = 1 / (1 + dist * 0.1);
      if (shade > 1) shade = 1;
      if (shade < 0.1) shade = 0.1;
      const gray = Math.floor(60 + 140 * shade);
      dctx.strokeStyle = `rgb(${gray},${gray},${gray})`;
      dctx.beginPath();
      dctx.moveTo(x, startY);
      dctx.lineTo(x, endY);
      dctx.stroke();
    }

    // враг как спрайт
    if (enemy.alive) {
      drawEnemySprite();
    }

    // пули как небольшие вспышки на экране (проекция в 2D сверху, можно упростить)
    // (опционально можно не рисовать)

    // оружие (пушка) снизу — просто прямоугольник
    drawGun();

    // HP врага
    drawEnemyHPBar();
  }

  function drawEnemySprite() {
    // угол и расстояние до врага
    const dx = enemy.x - player.x;
    const dy = enemy.y - player.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 0.001) return;
    const angleToEnemy = Math.atan2(dy, dx);
    let angleDiff = angleToEnemy - player.angle;

    // нормализуем -PI..PI
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

    const halfFov = FOV / 2;
    if (Math.abs(angleDiff) > halfFov + 0.2) {
      // враг вне экрана
      return;
    }

    const distProjPlane = (DW / 2) / Math.tan(halfFov);
    const spriteScreenX = Math.tan(angleDiff) * distProjPlane;

    const spriteSize = (TILE * distProjPlane) / dist; // высота
    const spriteScreenY = DH / 2;

    const xCenter = DW / 2 + spriteScreenX;
    const yTop = spriteScreenY - spriteSize / 2;

    const w = spriteSize * 0.6;
    const h = spriteSize;

    dctx.fillStyle = '#f97316';
    dctx.fillRect(xCenter - w / 2, yTop, w, h);
    dctx.strokeStyle = '#111827';
    dctx.lineWidth = 2;
    dctx.strokeRect(xCenter - w / 2, yTop, w, h);
  }

  function drawGun() {
    const gunWidth = DW * 0.25;
    const gunHeight = DH * 0.25;
    const x = DW / 2 - gunWidth / 2;
    const y = DH - gunHeight - 10;

    dctx.fillStyle = '#111827';
    dctx.fillRect(x, y, gunWidth, gunHeight);
    dctx.strokeStyle = '#e5e7eb';
    dctx.lineWidth = 2;
    dctx.strokeRect(x, y, gunWidth, gunHeight);

    // небольшая "морда" ствола
    dctx.fillStyle = '#e5e7eb';
    dctx.fillRect(DW/2 - 8, y, 16, 8);
  }

  function drawEnemyHPBar() {
    const barWidth = 200;
    const barHeight = 10;
    const x = (DW - barWidth) / 2;
    const y = 10;

    dctx.fillStyle = '#111827';
    dctx.fillRect(x, y, barWidth, barHeight);
    dctx.fillStyle = '#ef4444';
    const w = (enemy.hp / enemy.maxHp) * barWidth;
    dctx.fillRect(x, y, Math.max(0, w), barHeight);

    dctx.fillStyle = '#e5e7eb';
    dctx.font = '10px system-ui';
    dctx.fillText('Цель (HP: ' + enemy.hp.toFixed(0) + ')', x, y - 2);
  }

  let lastTime = performance.now();
  function doomLoop(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    if (mode === 'doom') {
      updateDoom(dt);
      drawDoom();
    }
    requestAnimationFrame(doomLoop);
  }

  requestAnimationFrame(doomLoop);

  // стартовое сообщение
  log('Готово. Режим шашек активен. Включи 3D арену — там псевдо-Doom с коридорами, врагом и стрельбой.');
})();
</script>
</body>
</html>

