<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Шашки + PvP арена</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    header {
      padding: 12px 16px 4px;
      text-align: center;
    }
    h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    p.subtitle {
      margin: 4px 0 0;
      font-size: 12px;
      color: #9ca3af;
    }
    .layout {
      width: 100%;
      max-width: 900px;
      padding: 8px 16px 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }
    .board-wrapper {
      background: radial-gradient(circle at top, #0b1120 0, #020617 50%, #000 100%);
      padding: 12px;
      border-radius: 16px;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 36px rgba(0,0,0,0.7);
    }
    #board {
      border: 2px solid #1f2937;
      border-radius: 8px;
    }
    .info {
      font-size: 12px;
      color: #9ca3af;
      text-align: center;
    }
    .info strong { color: #e5e7eb; }
    .log {
      font-size: 11px;
      color: #6b7280;
      font-family: monospace;
      background: rgba(15,23,42,0.85);
      border-radius: 10px;
      padding: 6px 10px;
      border: 1px solid #111827;
      max-height: 120px;
      overflow-y: auto;
      white-space: pre-line;
      width: 100%;
      max-width: 900px;
    }
    button {
      background: #1d4ed8;
      color: #e5e7eb;
      border: 1px solid #1d4ed8;
      border-radius: 999px;
      padding: 5px 11px;
      font-size: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 0.15s ease-out, transform 0.1s ease-out, box-shadow 0.1s ease-out;
    }
    button.secondary {
      background: #0f172a;
      border-color: #334155;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }

    /* Оверлей арены */
    #battleOverlay {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    #battleOverlay.visible {
      display: flex;
    }
    #battleInfo {
      font-size: 13px;
      color: #e5e7eb;
      margin-bottom: 8px;
      text-align: center;
    }
    #battleCanvas {
      background: #020617;
      border-radius: 16px;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 36px rgba(0,0,0,0.8);
    }
    #battleHint {
      margin-top: 6px;
      font-size: 11px;
      color: #9ca3af;
      text-align: center;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
      font-size: 10px;
      border-radius: 999px;
      background: #0f172a;
      border: 1px solid #1f2937;
      margin: 0 4px;
    }
  </style>
</head>
<body>
<header>
  <h1>Шашки с PvP-ареной</h1>
  <p class="subtitle">Попытка побить шашку запускает бой 1×1 сверху. Победитель остаётся на доске.</p>
</header>

<div class="layout">
  <div class="board-wrapper">
    <canvas id="board" width="480" height="480"></canvas>
  </div>
  <div class="info">
    <div>Ход: <strong><span id="turnText">Белые</span></strong></div>
    <div>Игроки ходят мышкой: клик по своей шашке → клик по клетке. При взятии запускается бой.</div>
    <div style="margin-top:4px;">
      <button id="resetBtn" class="secondary">Сбросить партию</button>
    </div>
  </div>
  <div class="log" id="log">Игра загружена. Ход белых.</div>
</div>

<!-- Оверлей арены -->
<div id="battleOverlay">
  <div id="battleInfo">
    PvP-бой за шашку. <br/>
    <span class="badge">Игрок 1 (атакующий): W A S D + Space (стрельба)</span><br/>
    <span class="badge">Игрок 2 (защищающийся): I J K L + Enter (стрельба)</span><br/>
    В круге безопасной зоны дамаг не идёт. Вне круга здоровье тает.
  </div>
  <canvas id="battleCanvas" width="640" height="400"></canvas>
  <div id="battleHint">Ждите, пока один умрёт. После этого бой закроется и шашка останется/умрёт.</div>
</div>

<script>
(function() {
  // ==========================
  // ЛОГ УТИЛИТА
  // ==========================
  const logEl = document.getElementById('log');
  function log(msg) {
    const t = new Date().toLocaleTimeString('ru-RU', { hour12: false });
    const text = `[${t}] ${msg}`;
    logEl.textContent = text + '\n' + logEl.textContent;
  }

  // ==========================
  // ШАШКИ: МОДЕЛЬ
  // ==========================
  const boardCanvas = document.getElementById('board');
  const bctx = boardCanvas.getContext('2d');
  const SIZE = 8;
  const CELL = boardCanvas.width / SIZE;

  // board[y][x] = {color:'w'|'b', king:boolean}
  let board = [];
  let currentPlayer = 'w'; // w = белые, b = чёрные
  let selected = null; // {x,y}
  let battlePending = null; // контекст боя
  const turnText = document.getElementById('turnText');

  function initBoard() {
    board = [];
    for (let y = 0; y < SIZE; y++) {
      const row = [];
      for (let x = 0; x < SIZE; x++) {
        row.push(null);
      }
      board.push(row);
    }
    // простая начальная расстановка: чёрные сверху (0-2), белые снизу (5-7)
    for (let y = 0; y < 3; y++) {
      for (let x = 0; x < SIZE; x++) {
        if ((x + y) % 2 === 1) {
          board[y][x] = { color: 'b', king: false };
        }
      }
    }
    for (let y = 5; y < 8; y++) {
      for (let x = 0; x < SIZE; x++) {
        if ((x + y) % 2 === 1) {
          board[y][x] = { color: 'w', king: false };
        }
      }
    }
    currentPlayer = 'w';
    selected = null;
    battlePending = null;
    updateTurnText();
    drawBoard();
  }

  function updateTurnText() {
    turnText.textContent = currentPlayer === 'w' ? 'Белые' : 'Чёрные';
  }

  function drawBoard() {
    // клетки
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        const dark = (x + y) % 2 === 1;
        bctx.fillStyle = dark ? '#111827' : '#e5e7eb';
        bctx.fillRect(x * CELL, y * CELL, CELL, CELL);

        // подсветка выбранной клетки
        if (selected && selected.x === x && selected.y === y) {
          bctx.fillStyle = 'rgba(250,204,21,0.3)';
          bctx.fillRect(x * CELL, y * CELL, CELL, CELL);
        }

        const piece = board[y][x];
        if (piece) {
          bctx.beginPath();
          bctx.arc(
            x * CELL + CELL / 2,
            y * CELL + CELL / 2,
            CELL * 0.35,
            0, Math.PI * 2
          );
          bctx.fillStyle = piece.color === 'w' ? '#f9fafb' : '#0f172a';
          bctx.fill();
          bctx.lineWidth = 2;
          bctx.strokeStyle = piece.color === 'w' ? '#e5e7eb' : '#374151';
          bctx.stroke();

          // дамка
          if (piece.king) {
            bctx.beginPath();
            bctx.arc(
              x * CELL + CELL / 2,
              y * CELL + CELL / 2,
              CELL * 0.18,
              0, Math.PI * 2
            );
            bctx.fillStyle = piece.color === 'w' ? '#fbbf24' : '#f97316';
            bctx.fill();
          }
        }
      }
    }
  }

  function getCellFromEvent(evt) {
    const rect = boardCanvas.getBoundingClientRect();
    const x = Math.floor((evt.clientX - rect.left) / CELL);
    const y = Math.floor((evt.clientY - rect.top) / CELL);
    if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return null;
    return { x, y };
  }

  function isDarkCell(x, y) {
    return (x + y) % 2 === 1;
  }

  function handleBoardClick(evt) {
    if (battleActive) return; // во время боя доска не реагирует
    const cell = getCellFromEvent(evt);
    if (!cell) return;
    const { x, y } = cell;
    if (!isDarkCell(x, y)) return;

    const piece = board[y][x];

    if (selected) {
      // попытка хода/боя
      if (selected.x === x && selected.y === y) {
        selected = null;
        drawBoard();
        return;
      }
      tryMove(selected.x, selected.y, x, y);
      return;
    } else {
      // выбор своей шашки
      if (piece && piece.color === currentPlayer) {
        selected = { x, y };
        drawBoard();
        return;
      }
    }
  }

  function tryMove(fromX, fromY, toX, toY) {
    const piece = board[fromY][fromX];
    if (!piece) {
      selected = null;
      drawBoard();
      return;
    }
    if (board[toY][toX]) {
      // занято
      selected = null;
      drawBoard();
      return;
    }

    const dx = toX - fromX;
    const dy = toY - fromY;

    // простое движение на 1 вперёд по диагонали
    const dir = piece.color === 'w' ? -1 : 1; // белые сверху вниз? у нас белые внизу -> ходят вверх (-1)
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);

    // движение без боя
    if (absDx === 1 && absDy === 1) {
      // для обычной шашки ограничим движение только вперёд
      if (!piece.king && dy !== dir) {
        selected = null;
        drawBoard();
        return;
      }
      board[toY][toX] = piece;
      board[fromY][fromX] = null;
      maybeKing(piece, toY);
      endTurn();
      return;
    }

    // попытка боя: прыжок через одну клетку по диагонали
    if (absDx === 2 && absDy === 2) {
      const midX = fromX + dx / 2;
      const midY = fromY + dy / 2;
      const midPiece = board[midY][midX];
      if (!midPiece || midPiece.color === piece.color) {
        selected = null;
        drawBoard();
        return;
      }
      // здесь запускаем PvP вместо автоматического снятия
      battlePending = {
        fromX, fromY,
        midX, midY,
        toX, toY,
        attackerColor: piece.color,
        defenderColor: midPiece.color,
        attackerIsKing: piece.king,
        defenderIsKing: midPiece.king
      };
      selected = null;
      drawBoard();
      startBattle(battlePending);
      return;
    }

    // иначе ничего
    selected = null;
    drawBoard();
  }

  function maybeKing(piece, y) {
    if (piece.king) return;
    if (piece.color === 'w' && y === 0) piece.king = true;
    if (piece.color === 'b' && y === SIZE - 1) piece.king = true;
  }

  function endTurn() {
    currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
    updateTurnText();
    drawBoard();
    log(`Ход передан. Теперь ходит ${currentPlayer === 'w' ? 'Белые' : 'Чёрные'}.`);
  }

  // результат боя: 'attacker' или 'defender'
  function resolveBattleResult(result) {
    if (!battlePending) return;
    const ctx = battlePending;
    battlePending = null;

    const attackerPiece = board[ctx.fromY][ctx.fromX];
    const defenderPiece = board[ctx.midY][ctx.midX];

    if (!attackerPiece || !defenderPiece) {
      drawBoard();
      return;
    }

    if (result === 'attacker') {
      // атакующий побеждает: обычный шашечный результат
      board[ctx.midY][ctx.midX] = null;
      board[ctx.fromY][ctx.fromX] = null;
      board[ctx.toY][ctx.toX] = attackerPiece;
      maybeKing(attackerPiece, ctx.toY);
      log(`Атакующий выигрывает PvP. Шашка ${attackerPiece.color === 'w' ? 'белых' : 'чёрных'} продвигается и бьёт.`);
      endTurn();
    } else {
      // защитник побеждает: атакующая шашка погибает, защищающаяся остаётся
      board[ctx.fromY][ctx.fromX] = null;
      // защитник остаётся на месте
      log(`Защитник выигрывает PvP. Атакующая шашка уничтожена, оборона удержана.`);
      endTurn();
    }

    drawBoard();
  }

  // ==========================
  // ШАШКИ: ИНИЦИАЛИЗАЦИЯ
  // ==========================
  boardCanvas.addEventListener('click', handleBoardClick);
  document.getElementById('resetBtn').addEventListener('click', () => {
    initBoard();
    log('Партия сброшена.');
  });
  initBoard();

  // ==========================
  // PVP-АРЕНА
  // ==========================
  const battleOverlay = document.getElementById('battleOverlay');
  const battleCanvas = document.getElementById('battleCanvas');
  const ctx = battleCanvas.getContext('2d');

  let battleActive = false;
  let lastTime = 0;

  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code] = true; });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  let player1, player2, bullets, safeZone, boxes;

  function startBattle(ctxInfo) {
    battleActive = true;
    battleOverlay.classList.add('visible');
    // параметры игроков
    // базовые характеристики
    const baseHP = 100;
    const baseSpeed = 120; // px/сек
    const baseDamage = 20;

    // если дамка -> баф
    const atkBuff = ctxInfo.attackerIsKing ? 1.5 : 1.0;
    const defBuff = ctxInfo.defenderIsKing ? 1.5 : 1.0;

    player1 = {
      // атакующий — слева
      x: battleCanvas.width * 0.25,
      y: battleCanvas.height * 0.5,
      r: 12,
      color: '#38bdf8',
      hp: baseHP * atkBuff,
      maxHp: baseHP * atkBuff,
      speed: baseSpeed * (1 + (atkBuff - 1) * 0.3),
      damage: baseDamage * atkBuff,
      cooldown: 0,
      cooldownTime: 0.4 / atkBuff // чем сильнее, тем чаще стреляет
    };
    player2 = {
      // защитник — справа
      x: battleCanvas.width * 0.75,
      y: battleCanvas.height * 0.5,
      r: 12,
      color: '#f97316',
      hp: baseHP * defBuff,
      maxHp: baseHP * defBuff,
      speed: baseSpeed * (1 + (defBuff - 1) * 0.3),
      damage: baseDamage * defBuff,
      cooldown: 0,
      cooldownTime: 0.4 / defBuff
    };

    bullets = [];

    safeZone = {
      cx: battleCanvas.width / 2,
      cy: battleCanvas.height / 2,
      radius: 220,
      shrinkRate: 15 // пикселей в секунду
    };

    boxes = [
      { x: 260, y: 160, w: 40, h: 60 },
      { x: 340, y: 260, w: 60, h: 40 },
      { x: 190, y: 260, w: 40, h: 40 },
      { x: 420, y: 140, w: 40, h: 40 }
    ];

    lastTime = performance.now();
    requestAnimationFrame(battleLoop);
    log(`Запущен PvP-бой: атакующий (${ctxInfo.attackerColor}), защитник (${ctxInfo.defenderColor}). Дамка даёт усиление.`);
  }

  function endBattleInternal(winner) {
    battleActive = false;
    battleOverlay.classList.remove('visible');
    resolveBattleResult(winner);
  }

  function battleLoop(timestamp) {
    if (!battleActive) return;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    updateBattle(dt);
    drawBattle();

    if (battleActive) {
      requestAnimationFrame(battleLoop);
    }
  }

  function updateBattle(dt) {
    // управление игроками
    handlePlayerMovement(player1, dt, {
      up: 'KeyW', down: 'KeyS', left: 'KeyA', right: 'KeyD'
    });
    handlePlayerMovement(player2, dt, {
      up: 'KeyI', down: 'KeyK', left: 'KeyJ', right: 'KeyL'
    });

    // стрельба
    handleShooting(player1, dt, 'Space', player2);
    handleShooting(player2, dt, 'Enter', player1);

    // обновляем пули
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // вылетело за экран
      if (b.x < 0 || b.x > battleCanvas.width || b.y < 0 || b.y > battleCanvas.height) {
        bullets.splice(i, 1);
        continue;
      }

      // столкновение с ящиками
      if (bulletHitsBox(b)) {
        bullets.splice(i, 1);
        continue;
      }

      // попадание
      if (!b.fromP1 && circleHit(player1, b)) {
        player1.hp -= b.damage;
        bullets.splice(i, 1);
        if (player1.hp <= 0) {
          player1.hp = 0;
          log('Игрок 1 погиб. Победил защитник.');
          endBattleInternal('defender');
          return;
        }
        continue;
      }
      if (b.fromP1 && circleHit(player2, b)) {
        player2.hp -= b.damage;
        bullets.splice(i, 1);
        if (player2.hp <= 0) {
          player2.hp = 0;
          log('Игрок 2 погиб. Победил атакующий.');
          endBattleInternal('attacker');
          return;
        }
        continue;
      }
    }

    // зона: сужение + дамаг
    safeZone.radius -= safeZone.shrinkRate * dt;
    if (safeZone.radius < 40) safeZone.radius = 40;

    applyZoneDamage(player1, dt);
    applyZoneDamage(player2, dt);

    if (player1.hp <= 0 && player2.hp <= 0) {
      // ничья: можно считать, что защитник удержал, или убили оба
      log('Оба погибли. Считаем, что оборона удержана.');
      endBattleInternal('defender');
      return;
    } else if (player1.hp <= 0) {
      player1.hp = 0;
      log('Игрок 1 погиб от зоны/огня. Победил защитник.');
      endBattleInternal('defender');
      return;
    } else if (player2.hp <= 0) {
      player2.hp = 0;
      log('Игрок 2 погиб от зоны/огня. Победил атакующий.');
      endBattleInternal('attacker');
      return;
    }
  }

  function handlePlayerMovement(p, dt, keysMap) {
    let vx = 0, vy = 0;
    if (keys[keysMap.up]) vy -= 1;
    if (keys[keysMap.down]) vy += 1;
    if (keys[keysMap.left]) vx -= 1;
    if (keys[keysMap.right]) vx += 1;
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;

    const speed = p.speed;
    let newX = p.x + vx * speed * dt;
    let newY = p.y + vy * speed * dt;

    // границы арены
    const margin = p.r + 4;
    newX = Math.max(margin, Math.min(battleCanvas.width - margin, newX));
    newY = Math.max(margin, Math.min(battleCanvas.height - margin, newY));

    // коллизия с ящиками
    const temp = { x: newX, y: newY, r: p.r };
    for (const box of boxes) {
      if (circleBoxCollision(temp, box)) {
        // не двигаем, если врезались
        return;
      }
    }

    p.x = newX;
    p.y = newY;
  }

  function handleShooting(p, dt, keyCode, enemy) {
    p.cooldown -= dt;
    if (p.cooldown < 0) p.cooldown = 0;
    if (!keys[keyCode]) return;
    if (p.cooldown > 0) return;

    // направление: стреляем в сторону врага
    const dx = enemy.x - p.x;
    const dy = enemy.y - p.y;
    const len = Math.hypot(dx, dy) || 1;
    const dirX = dx / len;
    const dirY = dy / len;
    const speed = 260;

    bullets.push({
      x: p.x,
      y: p.y,
      vx: dirX * speed,
      vy: dirY * speed,
      damage: p.damage,
      fromP1: (p === player1)
    });

    p.cooldown = p.cooldownTime;
  }

  function bulletHitsBox(b) {
    for (const box of boxes) {
      if (b.x >= box.x && b.x <= box.x + box.w &&
          b.y >= box.y && b.y <= box.y + box.h) {
        return true;
      }
    }
    return false;
  }

  function circleHit(p, b) {
    const dx = p.x - b.x;
    const dy = p.y - b.y;
    const dist = Math.hypot(dx, dy);
    return dist <= p.r;
  }

  function circleBoxCollision(circle, box) {
    const closestX = Math.max(box.x, Math.min(circle.x, box.x + box.w));
    const closestY = Math.max(box.y, Math.min(circle.y, box.y + box.h));
    const dx = circle.x - closestX;
    const dy = circle.y - closestY;
    return dx*dx + dy*dy < circle.r * circle.r;
  }

  function applyZoneDamage(p, dt) {
    const dx = p.x - safeZone.cx;
    const dy = p.y - safeZone.cy;
    const d = Math.hypot(dx, dy);
    if (d > safeZone.radius) {
      // дамаг от зоны
      p.hp -= 15 * dt;
    }
  }

  function drawBattle() {
    ctx.clearRect(0, 0, battleCanvas.width, battleCanvas.height);

    // фон
    ctx.fillStyle = '#020617';
    ctx.fillRect(0, 0, battleCanvas.width, battleCanvas.height);

    // зона
    ctx.beginPath();
    ctx.arc(safeZone.cx, safeZone.cy, safeZone.radius, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(56,189,248,0.06)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(56,189,248,0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // граница арены
    ctx.strokeStyle = '#1f2937';
    ctx.lineWidth = 3;
    ctx.strokeRect(4, 4, battleCanvas.width - 8, battleCanvas.height - 8);

    // ящики
    for (const box of boxes) {
      ctx.fillStyle = '#1f2937';
      ctx.fillRect(box.x, box.y, box.w, box.h);
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 2;
      ctx.strokeRect(box.x, box.y, box.w, box.h);
    }

    // пули
    for (const b of bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
      ctx.fillStyle = b.fromP1 ? '#38bdf8' : '#f97316';
      ctx.fill();
    }

    // игроки
    drawPlayer(player1);
    drawPlayer(player2);

    // HP-панель
    drawHPBars();
  }

  function drawPlayer(p) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fillStyle = p.color;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#020617';
    ctx.stroke();

    // маленький "ствол" в сторону центра (визуал)
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    const angleToCenter = Math.atan2(safeZone.cy - p.y, safeZone.cx - p.x);
    const len = p.r + 6;
    ctx.lineTo(p.x + Math.cos(angleToCenter) * len, p.y + Math.sin(angleToCenter) * len);
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  function drawHPBars() {
    const barWidth = 180;
    const barHeight = 10;

    // игрок 1
    ctx.fillStyle = '#111827';
    ctx.fillRect(20, 20, barWidth, barHeight);
    ctx.fillStyle = '#22c55e';
    const w1 = (player1.hp / player1.maxHp) * barWidth;
    ctx.fillRect(20, 20, Math.max(0, w1), barHeight);
    ctx.fillStyle = '#e5e7eb';
    ctx.font = '10px system-ui';
    ctx.fillText('Игрок 1 (атакующий)', 20, 16);

    // игрок 2
    ctx.fillStyle = '#111827';
    ctx.fillRect(battleCanvas.width - 20 - barWidth, 20, barWidth, barHeight);
    ctx.fillStyle = '#f97316';
    const w2 = (player2.hp / player2.maxHp) * barWidth;
    ctx.fillRect(battleCanvas.width - 20 - barWidth, 20, Math.max(0, w2), barHeight);
    ctx.fillStyle = '#e5e7eb';
    ctx.fillText('Игрок 2 (защитник)', battleCanvas.width - 20 - barWidth, 16);
  }
})();
</script>
</body>
</html>

